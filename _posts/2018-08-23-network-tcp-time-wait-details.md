---
layout: post
title: TCP状态之开山篇
date: 2018-09-04 22:30:00
tags: [网络, 握手, TCP]
---

### 前言

因为最近遇到点关于TIME_WAIT的问题, 随手在网上搜索了关于如何减少LINUX 服务器的TIME_WAIT数量, 通过设置网上提及的那些参数, 确实起到了作用, 但是下来之后, 想了解一下为什么会出现TIME_WAIT, 通过网上搜索, 看TCP的状态转换; 终于得知了TCP TIME_WAIT状态, 但这只是迈出了解TIME_WAIT的第一步; 后面逐层了解更加深层次的网络知识;


### TCP状态转换

对于稍微了解一点TCP原理的同学都知道, TCP是可靠的通信协议; 建立连接的时候会经过3次握手, 断开连接的时候会经过4次挥手; 而TIME_WAIT状态正是出现在挥手的时候; 在网上搜索TCP状态转换的时候真的是五花八门的图都有, 但知识的准确性有待考究.

为此, 我专门去专业的计算机网络中寻找答案, 终于在《计算机网络自顶向下方法》一书中找到了很精确、清晰的TCP状态转换图;

![TCP各端状态转换图](/assets/images/2018-09-06-tcp_state_transfer.png)

1、客户机TCP刚开始处于CLOSE状态, 服务器TCP处于CLOSE状态;(这里指的是服务器与某一个客户机尚未建立任何连接)

2、客户机的应用程序发起一个新的TCP连接(在Java中通过创建一个Socket对象来完成), 这时候客户机的TCP连接会发送一个SYN的报文段给到服务器TCP连接. 客户机在发送过SYN报文段之后, 会进入SYN_SEND的状态; 

3、当服务器TCP连接收到客户机的SYN报文段之后, 服务器状态会有LISTEN状态转变为SYN_RECV状态, 同时会向客户机TCP连接发送一个SYN + ACK的报文段, 当客户机收到该报文段之后, 状态会由SYN_SEND状态转变为ESTABLISHED状态. 

4、然后客户机会向服务器发送确认报文ACK, 当服务器收到该ACK报文之后, 服务器会有SYN_RECV转变为ESTABLISHED状态

5、中间会有一些数据通信过程就不多说了. 当数据传输完毕之后, 我们假设由客户端主动断开连接(当然也有可能是服务器端主动断开的连接, 这个也是后面需要探讨的一个点)

6、客户机主动断开连接, 会向服务器发送一个FIN报文段 表示客户机要断开连接了. 客户机在发送完FIN之后, 状态会由ESTABLISHED转变为FIN_WAIT1状态

7、服务端在收到客户机的FIN报文段之后, 服务端状态会由ESTABLISHED状态转换为CLOSE_WAIT状态, 同时会发送ACK给客户机, 表示客户机发送的FIN报文 服务端已收到; 

8、当客户机收到服务器的ACK报文段之后, 客户机的状态会由FIN_WAIT1状态转化为FIN_WAIT2状态, 表示等待服务器的断开连接的FIN报文段

9、在服务器的CLOSE_WAIT状态期间可能还会将TCP缓存中的东西发送给客户端, 发送完毕之后, 服务端会发送FIN报文段给客户机, 此时服务器的状态有CLOSE_WAIT状态转变为LAST_ACK状态

10、当客户机收到服务端的FIN报文段之后, 客户机TCP状态会由FIN_WAIT2转换为TIME_WAIT状态, 同时会发送ACK给服务器端, 服务器端收到客户机的ACK之后, 状态会由LAST_ACK转变为CLOSE状态

对于TCP状态转换概念, 开头想了好长时间都没有想到一个完美的开头; 所以就先写一点关于TCP状态转换的认知, 后面慢慢的把这方面的东西补充起来之后再整合为一篇完整的文章吧;

后面打算从几方面去探索

1、在HTTP协议模型中, 什么时候客户端会产生TIME_WAIT, 什么时候服务端会产生TIME_WAIT;

2、TIME_WAIT在不同角色的机器上(客户端, 服务端)产生后对于系统的影响

3、与TIME_WAIT相关参数的理解与设置之后对系统产生什么影响

4、在CLIENT => NGINX => upstream server => DB(Redis)模型中产生TIME_WAIT的影响, 以及如何调优

5、NGINX中的upstream设置keepalive 对于系统优化有什么优缺点

6、为什么TIME_WAIT的超时时间为2MSL, 理论依据是什么.
